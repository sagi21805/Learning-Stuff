The previous sections explain mechanisms and instruction that are available to code running at all privilege levels to get a better understanding of the x86 architecture. This section discusses two fundamental system-level mechanisms: 
- _Virtual Address Translation_
- _Exception/Interrupt handling_
# Address Translation
The physical memory on a computer is divided into a 4KB units called _pages_. (A page can be more then 4KB, but will not be discussed here) Memory addresses are divided into two categories: 
- Virtual Addresses
- Physical Addresses
Virtual addresses are used when processor paging is enabled
```nasm
mov eax, [0x12345678] 
; read from virtual memory address 0x12345678
mov [eax], ecx
; write ECX on the virtual address of EAX
```
Physical addresses are the actual memory locations used by the processor when accessing memory. The processor's Memory Management Unit (MMU) transparently translate every virtual address into a physical addresses before accessing it. While virtual addresses may seem like another number to the user, there is a structure to it when viewed by the MMU. On x86 systems with Physical Address Extension (PAE) support, a virtual memory address can be divided into indices of three tables:
- _Page Directory Pointer Table_ (PDPT)
- _Page Directory_ (PD)
- _Page Table_ (PT), 
- _Page Table Entry_ (PTE) (Basically page offset) 
A <u>PDPT</u> is an array of four 8-byte elements, each pointing to a <u>PD</u> which is an array of 512 
8-byte elements, each pointing to a <u>PT</u>  which is another array of 512 8-byte elements, each containing a <u>PTE</u>     
<u>Address Translation Process</u>
This process revolves around these three tables and the _CR3_ register which holds the base **Physical** memory address of the page table. for example translating address <u>0xBF80EE6B</u> on a real system.![[Pasted image 20250122195424.png]]
```
Base Address of CR3 = 0x85C01E0

Reading the Second Index of the PDPT (0x85C01E0 + 2*8) We Get
PD Entry => 0x000000000D66E001

Per documentation, the bottom 12 bits of a PDPT entry are flags/reserved bits
and the remaining ones are used as the physical address of the PD base bit 63 is the NX flag on a specific page, which tells the computer if it is not executable.

After clearing the bootom 12 bits we remain with the PD Base address 
which is 0x0D66E000

looking at index 0x1FC (0x0D66E000 + 0x1FC*8) we get 
0x000000000964B063

Again per documentationm the bottom 12 bits are used for flag/reserved, and the remaining are used as base for PT 

Again 12 bits can be cleared to get base address at index (0x0964B000 + 0xE*8)
which gives us
0x0000000006694021

Again the bottom 12 bits can be cleared to get the base of a page entry to get
0x06694000
then to get the offset in the page just add the offset, to get the finel address
----------
0x06694E6B
----------
which has actual data in it.
To fool processes that they have thier own memory space, they are associated 
with thier own CR3 register, which is on their pagetable, which makes 
```
# Interrupts and Exceptions
This section briefly discusses interrupts and exceptions. In contemporary computer systems, the processor is typically connected to peripheral devices through a data bus such as PCI Express, FireWire or USB. When a device requires the processor's attention, it causes an interrupt that forces the processor to pause whatever it is doing, and handle the device's request. 
_How Does the processor know how to handle the request?_ 
At the highest level, one can think of an interrupt as being associated with a number that is then used to index into an array of function pointers. When the processor receives the interrupt, it executes the function at the index associated with the interrupt, and resumes execution at wherever it was before the interrupt occurred. These are called _Hardware Interrupts_ because they are generated by hardware devices and asynchronous by nature.
For the purpose of this discussion, exceptions can be classified into two categories: _faults_ and _traps_ 
<u>Fault</u> - correctable exception. For example, when the processor executes an instruction that references a valid memory address but the data is not present in main memory (it was paged out), a page fault exception is generated. The processor handles this by saving the current execution state, calling the page fault handler, to correct this exception (by paging the data).
<u>Trap</u> - This is an exception that is caused by executing special kinds of instruction. For example the instruction SYSENTER causes the processor to begin executing the generic system call handler; after the handler is done, executing is resumed at the instruction immediately after SYSENTER. 
The major difference is where execution resumes. Operating systems commonly implement system calls through the interrupt and exception mechanism.
The previous sections explain mechanisms and instruction that are available to code running at all privilege levels to get a better understanding of the x86 architecture. This section discusses two fundamental system-level mechanisms: 
- _Virtual Address Translation_
- _Exception/Interrupt handling_
# Address Translation
The physical memory on a computer is divided into a 4KB units called _pages_. (A page can be more then 4KB, but will not be discussed here) Memory addresses are divided into two categories: 
- Virtual Addresses
- Physical Addresses
Virtual addresses are used when processor paging is enabled
```nasm
mov eax, [0x12345678] 
; read from virtual memory address 0x12345678
mov [eax], ecx
; write ECX on the virtual address of EAX
```
Physical addresses are the actual memory locations used by the processor when accessing memory. The processor's Memory Management Unit (MMU) transparently translate every virtual address into a physical addresses before accessing it. While virtual addresses may seem like another number to the user, there is a structure to it when viewed by the MMU. On x86 systems with Physical Address Extension (PAE) support, a virtual memory address can be divided into indices of three tables:
- _Page Directory Pointer Table_ (PDPT)
- _Page Directory_ (PD)
- _Page Table_ (PT), 
- _Page Table Entry_ (PTE) (Basically page offset) 
A <u>PDPT</u> is an array of four 8-byte elements, each pointing to a <u>PD</u> which is an array of 512 
8-byte elements, each pointing to a <u>PT</u>  which is another array of 512 8-byte elements, each containing a <u>PTE</u>     
<u>Address Translation Process</u>
This process revolves around these three tables and the _CR3_ register which holds the base **Physical** memory address of the page table. for example translating address <u>0xBF80EE6B</u> on a real system.![[Pasted image 20250122195424.png]]
```
Base Address of CR3 = 0x85C01E0

Reading the Second Index of the PDPT (0x85C01E0 + 2*8) We Get
PD Entry => 0x000000000D66E001

Per documentation, the bottom 12 bits of a PDPT entry are flags/reserved bits
and the remaining ones are used as the physical address of the PD base bit 63 is the NX flag on a specific page, which tells the computer if it is not executable.

After clearing the bootom 12 bits we remain with the PD Base address 
which is 0x0D66E000

looking at index 0x1FC (0x0D66E000 + 0x1FC*8) we get 
0x000000000964B063

Again per documentationm the bottom 12 bits are used for flag/reserved, and the remaining are used as base for PT 

Again 12 bits can be cleared to get base address at index (0x0964B000 + 0xE*8)
which gives us
0x0000000006694021

Again the bottom 12 bits can be cleared to get the base of a page entry to get
0x06694000
then to get the offset in the page just add the offset, to get the finel address
----------
0x06694E6B
----------
which has actual data in it.
To fool processes that they have thier own memory space, they are associated 
with thier own CR3 register, which is on their pagetable, which makes 
```
# Interrupts and Exceptions
This section briefly discusses interrupts and exceptions. In contemporary computer systems, the processor is typically connected to peripheral devices through a data bus such as PCI Express, FireWire or USB. When a device requires the processor's attention, it causes an interrupt that forces the processor to pause whatever it is doing, and handle the device's request. 
_How Does the processor know how to handle the request?_ 
At the highest level, one can think of an interrupt as being associated with a number that is then used to index into an array of function pointers. When the processor receives the interrupt, it executes the function at the index associated with the interrupt, and resumes execution at wherever it was before the interrupt occurred. These are called _Hardware Interrupts_ because they are generated by hardware devices and asynchronous by nature.
For the purpose of this discussion, exceptions can be classified into two categories: _faults_ and _traps_ 
<u>Fault</u> - correctable exception. For example, when the processor executes an instruction that references a valid memory address but the data is not present in main memory (it was paged out), a page fault exception is generated. The processor handles this by saving the current execution state, calling the page fault handler, to correct this exception (by paging the data).
<u>Trap</u> - This is an exception that is caused by executing special kinds of instruction. For example the instruction SYSENTER causes the processor to begin executing the generic system call handler; after the handler is done, executing is resumed at the instruction immediately after SYSENTER. 
The major difference is where execution resumes. Operating systems commonly implement system calls through the interrupt and exception mechanism.
# Interrupt Descriptor Table
The **Interrupt Descriptor Table** (**IDT**) is a binary data structure specific to the IA-32 and x86-64 architectures. The IDT entries are called <u>gates</u>. It can contain Interrupt Gates, Task Gates and Trap Gates. The location of the **IDT** is kept in the **IDTR** (**IDT** register). This is loaded using the **LIDT** assembly instruction, whose argument is a pointer to an **IDT Descriptor** structure
```C
typedef struct IDT {
	unsigned short limit;
	unsigned int / unsigned long long base; //x86_32 uses DWORD, x86_64 uses QWORD
}
```
This is practically an array of function pointers to handlers of interrupts, the handlers are called drivers and they most of the time signed by Microsoft. 
Each entry is 8 or 16 bytes long depending on the architecture. 

The IDT is at:
- 0x80ffffff in Windows
- 0xe8XXXXXX in Virtual PC
- 0xffXXXXXX in VMware

## Red Pill
Most of the time malware is analyzed on a virtual machine. and when the malware is analyzed it is ran by the user. In order to make the life harder on malware analysts, an advanced malware can change it's behavior if it can detect it is ran on a virtual machine. Red Pill is an anti-VM technique that executes the _SIDT_ instruction to grab the value of the IDTR register. The virtual machine monitor must relocate the guest’s IDTR to avoid conflict with the host’s IDTR. Since the virtual machine monitor is not notified when the virtual machine runs the _SIDT_ instruction, the IDTR for the virtual machine is returned. Red Pill tests for this discrepancy to detect the usage of VMware.
![[Pasted image 20250201191632.png]]
```nasm
mov al, [eax+5]
cmp al, 0FFh ; VMware signature in the IDT register
jnz short loc_401E19
```
# Interrupt Service Routine (ISR)
Drivers for physical devices that generate interrupts have at least one _Interrupt Service Routine_
The ISR must do whatever is appropriate to handle the device interrupt or to dismiss it. Basically do the minimal effort to handle the interrupt or ignore it, Then, it should only do whatever is necessary to save the state and queue a [[#Deferred Procedure Call]] (DPC) to finish the I/O operation at a lower priority (IRQL) than that at which the ISR executed.
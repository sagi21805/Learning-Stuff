# Part 0: Malware Analysis Primer
## Malware Analysis Techniques
Often when performing analysis, you will only have the malware executable, which won't be human readable. In order to make sense of it, you will use tools and tricks, that will help to identify what the malware is doing.
### Basic Static Analysis
- "Examine the executable without running it"
- This technique is very fast 
- Ineffective against sophisticated malware
This technique can confirm if the file is indeed malicious, and may provide information about the functionality of the malware 
### Basic Dynamic Analysis
- "Examine the executable <u>while running it</u> and examine it's behavior"
- Used to produce effective signatures
- Allows of better understanding of the program
This technique can help identify what the malware is actually doing. The user need to run the malware in separate environment so it won't infect him as well

### Advanced Static Analysis
- Reverse engineering the malware to assembly instruction
- The instruction are literally what the program do.
The instructions are literally what the CPU does, when turning the executable into instructions, it can be analyzed and then a malware analyst can infer what the program does.

### Advanced Dynamic Analysis 
- Use debugger to run the program line by line
- obtain information that is harder to get with static analysis
This technique uses a debugger to examine the state of the executable, the debugger runs the code line by line, and an analyst can notice the changes in the system within each line.

## Types of Malware
Analysis can be sped up, when you can make an educated guess about what the malware is trying to do, and then confirm those hypotheses. 
<u>Backdoor</u> - Malicious code the installs itself to a computer to allow the attacker remote access whenever he wants.
<u>Botnet</u> - Attacker first has a backdoor on some computers then it makes them all to do the same instruction, for example DDoS 
<u>Downloader</u> - Malicious code that exists only to download more malicious code
<u>Information Stealing Malware</u> - Collects information from the victim's computer and sends it to the attacker, for example a key-logger that can log passwords and credit card information.
<u>Launcher</u> - Malicious code that loads more malicious code, this can be used to launch the code with greater access to the system.
<u>Rootkit</u> - Malicious code that looks like innocent code, so it is harder to detect, most of the time this is paired with a backdoor
<u>Scareware</u> - Don't do actual damage to the system but scares the victim to buy or download some other malicious code.
<u>Spam Sending Malware</u> - Infects a users machine and then using it to spam 
<u>Worm or Virus</u> - Any of the above code, but it also copies it self to other systems.

Traditional malware may combine several on the niches above, and can also be classified based on whether the attacker target is mass or targeted.
### Malware Approaches
<u>Mass</u> - This is a shotgun approach, like scareware that is used to infect as many machines as possible. This is the most common kind and usually less sophisticated and easier to detect.

<u>Trageted</u> - This is a sniper approach, it is designed for a specific system or organization and it is one of a kind. This is the most scary stuff for organization, because they are harder to locate and most of the time have not seen before. Without deep analysis of that kind of malware it is very hard to remove and protect from the infection.

## General Rules
- Don't get too caught up in the details, Malware can be complex and large. Focus on key features and try to get the general view of things 
- Different tools and approaches are used for different jobs, if one tool doesn't work, try the other. 
- Malware analysis is a cat and mouse game. to succeed you must  able recognize, understand, and defeat the malware techniques and respond to changes and development of malware

# Part 1: Basic Analysis

Static Analysis in most of the time the first step, It describes the process of analyzing code or structure of a program, and determines its functionality.   
## Basic Static Techniques
This is a method of extracting useful information from the executable without running it, nor reversing it. 
- Using anti-virus to confirm maliciousness
- Using hashes to identify malware
- Gleaning information from a file's strings, functions and headers

### Anti-Virus Scanning: A Useful First Step
A good first step is to run the suspected file on multiple anti-viruses, because they may have already seen this malware. 
Most anti-viruses are not perfect, and mostly rely on file signatures, and pattern matching analysis to identify the suspicious file.
Simply, if the code is changed a bit, the signature is different, thus malware goes undetected because it is not in the database.

### Hashing: A Fingerprint for Malware
This is a common method used to uniquely identify malware. The malicious code run through a hashing program that produces a unique _hash_  that identifies that malware (sort of fingerprint). The Message-Digest Algorithm 5 (MD 5) is the most common hash function used for this case. 
With the hash is hand, you can:
- Use the hash as a label for that file
- Share that hash with other analysts
- Search the hash online to see if it was already identified

### Finding Strings
<u>String</u> - Text that is inside "", e.g "Hello World!"
A program contains strings if it prints a message, connects to a URL, or copies a file to specific location.
Searching strings in the program can give hints about it's functionality. for example, if a program access a URL, it will appear when searching for strings. String are mostly stored as ASCII or Unicode

_Microsoft uses the term_ Wide character String _for it's implementation of Unicode, which is a bit different then standards_

These codes are using numbers ending in a NULL to represent letters
![[Pasted image 20241216195351.png]]
![[Pasted image 20241216195410.png]]
- When searching for strings, context and formatting is ignored, so all possible strings are are generated.
- Sometimes the program that detects strings makes a false positive, which is not actually a string in the file. Most invalid strings are obvious, because they don't represent anything.

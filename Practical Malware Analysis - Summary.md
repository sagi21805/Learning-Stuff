# Part 0: Malware Analysis Primer
## Malware Analysis Techniques
Often when performing analysis, you will only have the malware executable, which won't be human readable. In order to make sense of it, you will use tools and tricks, that will help to identify what the malware is doing.
### Basic Static Analysis
- "Examine the executable without running it"
- This technique is very fast 
- Ineffective against sophisticated malware
This technique can confirm if the file is indeed malicious, and may provide information about the functionality of the malware 
### Basic Dynamic Analysis
- "Examine the executable <u>while running it</u> and examine it's behavior"
- Used to produce effective signatures
- Allows of better understanding of the program
This technique can help identify what the malware is actually doing. The user need to run the malware in separate environment so it won't infect him as well

### Advanced Static Analysis
- Reverse engineering the malware to assembly instruction
- The instruction are literally what the program do.
The instructions are literally what the CPU does, when turning the executable into instructions, it can be analyzed and then a malware analyst can infer what the program does.

### Advanced Dynamic Analysis 
- Use debugger to run the program line by line
- obtain information that is harder to get with static analysis
This technique uses a debugger to examine the state of the executable, the debugger runs the code line by line, and an analyst can notice the changes in the system within each line.

## Types of Malware
Analysis can be sped up, when you can make an educated guess about what the malware is trying to do, and then confirm those hypotheses. 
<u>Backdoor</u> - Malicious code the installs itself to a computer to allow the attacker remote access whenever he wants.
<u>Botnet</u> - Attacker first has a backdoor on some computers then it makes them all to do the same instruction, for example DDoS 
<u>Downloader</u> - Malicious code that exists only to download more malicious code
<u>Information Stealing Malware</u> - Collects information from the victim's computer and sends it to the attacker, for example a key-logger that can log passwords and credit card information.
<u>Launcher</u> - Malicious code that loads more malicious code, this can be used to launch the code with greater access to the system.
<u>Rootkit</u> - Malicious code that looks like innocent code, so it is harder to detect, most of the time this is paired with a backdoor
<u>Scareware</u> - Don't do actual damage to the system but scares the victim to buy or download some other malicious code.
<u>Spam Sending Malware</u> - Infects a users machine and then using it to spam 
<u>Worm or Virus</u> - Any of the above code, but it also copies it self to other systems.

Traditional malware may combine several on the niches above, and can also be classified based on whether the attacker target is mass or targeted.
### Malware Approaches
<u>Mass</u> - This is a shotgun approach, like scareware that is used to infect as many machines as possible. This is the most common kind and usually less sophisticated and easier to detect.

<u>Trageted</u> - This is a sniper approach, it is designed for a specific system or organization and it is one of a kind. This is the most scary stuff for organization, because they are harder to locate and most of the time have not seen before. Without deep analysis of that kind of malware it is very hard to remove and protect from the infection.

## General Rules
- Don't get too caught up in the details, Malware can be complex and large. Focus on key features and try to get the general view of things 
- Different tools and approaches are used for different jobs, if one tool doesn't work, try the other. 
- Malware analysis is a cat and mouse game. to succeed you must  able recognize, understand, and defeat the malware techniques and respond to changes and development of malware

# Part 1: Basic Analysis

Static Analysis in most of the time the first step, It describes the process of analyzing code or structure of a program, and determines its functionality.   
## Basic Static Techniques
This is a method of extracting useful information from the executable without running it, nor reversing it. 
- Using anti-virus to confirm maliciousness
- Using hashes to identify malware
- Gleaning information from a file's strings, functions and headers

### Anti-Virus Scanning: A Useful First Step
A good first step is to run the suspected file on multiple anti-viruses, because they may have already seen this malware. 
Most anti-viruses are not perfect, and mostly rely on file signatures, and pattern matching analysis to identify the suspicious file.
Simply, if the code is changed a bit, the signature is different, thus malware goes undetected because it is not in the database.

### Hashing: A Fingerprint for Malware
This is a common method used to uniquely identify malware. The malicious code run through a hashing program that produces a unique _hash_  that identifies that malware (sort of fingerprint). The Message-Digest Algorithm 5 (MD 5) is the most common hash function used for this case. 
With the hash is hand, you can:
- Use the hash as a label for that file
- Share that hash with other analysts
- Search the hash online to see if it was already identified

### Finding Strings
<u>String</u> - Text that is inside "", e.g "Hello World!"
A program contains strings if it prints a message, connects to a URL, or copies a file to specific location.
Searching strings in the program can give hints about it's functionality. for example, if a program access a URL, it will appear when searching for strings. String are mostly stored as ASCII or Unicode

_Microsoft uses the term_ Wide character String _for it's implementation of Unicode, which is a bit different then standards_

These codes are using numbers ending in a NULL to represent letters
![[Pasted image 20241216195351.png]]
![[Pasted image 20241216195410.png]]
- When searching for strings, context and formatting is ignored, so all possible strings are are generated.
- Sometimes the program that detects strings makes a false positive, which is not actually a string in the file. Most invalid strings are obvious, because they don't represent anything.
![[Pasted image 20241217172700.png]]

For example, this is an output, real strings and junk can be easily differentiated. More over much information can be extracted from the strings, like
- IP address that sends or gets data
- PowerShell commands like _GetLayout_ and _SetLayout_ 
- GDI32.dll is a meaningful because it is a library that is probably used.
- The error message can even say what is being sent.

## Packed and Obfuscated Malware
Malware writers often use packing or obfuscation to make their files more difficult to detect or analyze. _Obfuscated_ programs are ones whose execution, 

## Portable Executable File Format
- This is the file format for most windows executable and DLL files 
- This file contains information about the required functions, DLLs and all the information needed to load the files into memory.
- This file begins with a header that has information about the code, the required functions and DLLs,  and required memory space. 

## Linked Libraries and Functions
One of the most useful information we can gather about an executable, is it functions that it _imports_.
<u>Imported function</u> - This is a function that is located in another executable.
Knowing how library code is linked is critical for understanding the malware. 
The information about how a library is linked is inside the PE header

### Static, Runtime and Dynamic Linking
<u>Static linking</u> - This is the least common way of linking in windows, although it is common in Linux.
<u>Runtime Linking</u> - This is commonly done in malware, especially when it is packed or obfuscated, the library is linked on the runtime of the program with API calls like _LoadLibrary_, _GetProcAddress_, _LdrGetProcAddress_ and more.
In Linux, libraries can be loaded with _dlopen_.
<u>Dynamic Linking</u> - With this method linking is done dynamically at the start of the program. When the program is loaded to memory, the host OS searches for the libraries, and then when functions from the library are used they can be executed from the loaded lib code.

### Important Information
The PE header stores information on every library that is used and every function that is used.

### Common DLLs

| DLL                      | Descriptions                                                                                                                                                                                                                                                                                                                                                                                                         |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Kernel32.dll             | This is a common DLL that contains core functionality, such as access and manipulating of <u>memory</u>, <u>files</u>, and <u>hardware</u>.                                                                                                                                                                                                                                                                          |
| Advapi32.dll             | This DLL provides access to advanced core windows components such as the Service Manager and Registery                                                                                                                                                                                                                                                                                                               |
| User32.dll               | This DLL contains all the user-interface components for controlling and responding for user actions.                                                                                                                                                                                                                                                                                                                 |
| Gdi32.dll                | This DLL contains functions for displaying and manipulating graphics                                                                                                                                                                                                                                                                                                                                                 |
| Ntdll.dll                | This DLL is the interface for the windows kernel. Executable files generally don't import this file directly, although it is always imported indirectly by _Kernel32.dll_, if an executable imports this file, it means that the author intended to use functionality that is not normally available in window programs. Some tasks such as hiding functionality or manipulating processes, will use this interface. |
| WSock32.dll & Ws2_32.dll | These are networking DLLs. A program that accesses either of these most likely connects to a network or performs a network related task                                                                                                                                                                                                                                                                              |
| Wininet.dll              | This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP and NTP                                                                                                                                                                                                                                                                                                               |

## Function Naming Convention
<u>Ex Suffix</u> - When Microsoft updates a function, and the new function is incompatible with the old one, The new function is given the same name as the old one. Because Microsoft continues to support the old function, an _Ex_ suffix is added to the <u>New Function</u>, if it is updated twice the suffix is added twice.  
For example, _CreateWindowEx_

<u>A or W suffix</u> - Many functions that take strings as parameters, include an A or W suffix, This letter is not appearing in the documentation for the function; and it simply indicates that the function take a string parameter and there a two versions, one ASCII strings for the <u>A</u> suffix, and one function for Wide Strings for the <u>W</u> suffix.
For example _CreateDirectoryW_ -> means the directory name is expected as a wide strings

## Imported Functions
The PE header file also includes information about specific functions used by an executable. The names of those functions can help understand what the executable does.

## Exported Functions
Like imports, DLLs and EXEs export functions to interact with other programs and code. Typically a DLL implements one or more functions to export and then other DLLs or executable can import them. 
#Note
_Most of the time, imported functions are EXPORTED from a DLL because they are designed for this purpose, if an executable EXPORTS a function, it can bring great value to an analyst._

## Static Analysis in Practice
### PotentialKeylogger.exe: An Unpacked Executable
![[Pasted image 20241221115848.png]]
Like most average size programs, this executable contains large number of imported function. Unfortunately only a small minority are interesting.
Normally we wouldn't know that this malware is a potential key logger, and we will look for functions that provide the clues.
	
### Packed Program: A Dead End

![[Pasted image 20241224190050.png]]
This Table shows a complete list of functions imported by a second piece of unknown malware. This list tells us that the program is packed because it has almost no imports at all, even an hello world program will have more imports.

## The PE Headers and Sections
This file can provide considerably more information that just imports, This file format contains a header followed by a series of sections. 
The header contains data on the file itself, each sections contains useful information 

### <u>.text</u>
This sections contains the instructions that the CPU executes. All other sections store supporting information, generally this is the only sections that executes code.

### <u>.rdata</u>
This section contains the information about the import and export table, which is the information that is given from dependency walker or object dump. This section stores read only data, used by the program. Some time files have .edata and .idata for the export and import tables.

### <u>.data</u>
This section contains the program's global data, which is accessible from anywhere in the program. Local data is not stored in this section, or anywhere else in the PE file.
### <u>.rsrc</u>
This section contains resources used by the executable, that are not considered part of the execution, such as icons, images, menus, and strings. Strings can be stored here or in the main program

Section names most of the time are consistent across compilers, but can vary across different compilers. For example, Visual Studio uses .text but Borland Delphi uses _CODE_. Luckily, the default names are used most of the time. these are the most common ones -> 
![[Pasted image 20241224192403.png]]

As you can see from _PotentialKeyLogger.exe_, the .text, .rdata, .rsrc sections each has a _Virtual Size_ and size of _Raw Data_. The table below $\downarrow$ shows that these sections has almost the same size. The .data sections seems suspicious because it has a much larger virtual size that raw data size, but this is common in this section in windows. This info don't tell us this program is malicious but that is probably not packed and that the header was created by a compiler.

![[Pasted image 20241224200032.png]]

This output is from _PackedProgram.exe_. The sections in this file have a number of anomalies. The sections names <u>Dijfods</u>, <u>.sdfuok</u>, and <u>kijijl</u> are unusual, and the .text, .data, and .rdata sections are suspicious. The .text sections has a _Raw Size_ value of 0, meaning that it takes no space on disk. and a _Virtual Size_ of A000 which means this amount of memory will be allocated.
This is the section information from this program.
![[Pasted image 20241224201032.png]]
![[Pasted image 20241224201236.png]]

Ended at page 24 - merge from home computer